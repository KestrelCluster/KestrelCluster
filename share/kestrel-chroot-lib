#!/bin/bash

# Minimal reconfigure library. Functions defined in this library can be used
# on scripts run on the images under a chroot enviroment.


# File copying functions
#########################

# All this functions expect to have ${os_dir} variable correctly set

# copy_file <file> <to_file>
# 

copy_file() {
    local   file="${1}"
    local tofile="${2:-$1}"
    
    test_backup
    
    cp -a "${file}" "${os_dir}/${tofile}"
    
    perms_and_backup
}


# copy_file <file> <to_file>
# 

link_file() {
    local   file="${1%\(*\)}"
    local tofile="${2:-$1}"
    
    test_backup
    
    ( cd "${os_dir}/${file%/*}"
      ln -snf "${file##*/}" "${tofile}" )
    
    perms_and_backup
}


# template_file <file> <to_file>
# 

template_file() {
    local   file="${1}"
    local tofile="${2}"
    
    test_backup
    
    evaluate_template < "${file}" > "${os_dir}/${tofile}"
    
    perms_and_backup
}


# test_backup
# 
#     Makes the original backup when kestrel is installed, and also checks if 
#     a file has been modified by the user since the last reconfiguration.

test_backup() {
    local dest_file="${os_dir}/${tofile}"
    local back_file="${os_dir}/${KESTREL_BACKUP_DIR}/${tofile}"
    local last_file
    local dest_stat
    
    mkdir -p "${dest_file%/*}"
    mkdir -p "${back_file%/*}"
    
    if [ -f "${dest_file}" ]; then
        dest_stat=$(stat -c %Y "${dest_file}")

        # If the file has not been changed by the user, remove the backup of the
        # autogenerated file.
        if [ -L "${back_file}:last" ]; then
            last_file=$(readlink -n "${back_file}:last")
            
            [ "${dest_stat}" ==  "${last_file##*:}" ] &&
                rm "${back_file%/*}/${last_file}"
        
        # When installing the first time save the original file
        elif [[ "${action}" == @(install|enable) && 
           ! -L "${back_file}:orig" && ! -d "${dest_file}" ]]; then
            
            cp -a "${dest_file}" "${back_file}:${dest_stat}"
            
            ( cd "${back_file%/*}"
              ln -snf "${back_file##*/}:${dest_stat}" "${back_file##*/}:orig" )
        fi
    fi
}


# perms_and_backup
# 
#     Apply permissions and make a backup of the file.

perms_and_backup() {
    local dest_file="${os_dir}/${tofile}"
    local back_file="${os_dir}/${KESTREL_BACKUP_DIR}/${tofile}"
    local dest_stat
    
    [ -n "${user}"  ] && chown -v "${user}"   "${dest_file}"
    [ -n "${group}" ] && chown -v ":${group}" "${dest_file}"
    [ -n "${mode}"  ] && chmod -v "${mode}"   "${dest_file}"
    
    mkdir -p "${back_file%/*}"
    
    if [[ -e "${dest_file}" && ! -d "${dest_file}" ]]; then
        dest_stat=$(stat -c %Y "${dest_file}")
        
        cp -a "${dest_file}" "${back_file}:${dest_stat}"
        
        ( cd "${back_file%/*}"
          ln -snf "${back_file##*/}:${dest_stat}" "${back_file##*/}:last" )
    fi
}

# restore_file
# 

restore_file() {
    local dest_file="${os_dir}/${file}"
    local back_file="${os_dir}/${KESTREL_BACKUP_DIR}/${file}"
    local orig_link="${back_file}:orig"
    local orig_file="${back_file%/*}/"$(readlink -n "${orig_link}")
    
    # If the file has not been changed by the user, remove the backup of the
    # last autogenerated file.
    if [ -L "${back_file}:last" ]; then
        
        local dest_stat=$(stat -c %Y "${dest_file}")
        local last_file=$(readlink -n "${back_file}:last")
        local last_stat="${last_file##*:}"
        
        # Compare the actual stat, and the stat (on the name) of the last backup
        if [ ! "${dest_stat}" ==  "${last_stat}" ]; then
            rm "${back_file%/*}/${last_file}"
        else
            cp -a "${dest_file}" "${back_file}:${dest_stat}"
        fi
        
        rm "${back_file}:last"
    fi
    
    # If there was a backup, restore the backup
    if [ -L "${orig_link}" ]; then
        cp -a "${orig_file}" "${dest_file}"
        
        [[ "${action}" == @(desinstall|disable) ]] &&
        rm "${orig_link}"
    
    # Otherwise simply delete the file
    else
        [ -f "${dest_file}" ] &&
        rm "${dest_file}"
    fi
}


# File editing functions
#########################

# evaluate_template
# 

evaluate_template() {
    sed -r "${evaluation_script}"
}


# set_key_value <key> <value> <file> [<separator_re> [<separator> [<space>]]]
# 
#     Helps replacing/setting key-values on files.
#     By default the separator is the "=" character.
#     
#     Optional parameters
#         <separator_re>: Regular expression used to match the separator.
#         
#         <separator>   : Use <separator> if <separator_re> is not a printable
#                         expression.
#         
#         <space>       : Regular expression used to match the ignored spaces.
#                         By default "[:space:]*"
#         
#     Examples:
#         set_key_value FRONTEND_IP "192.168.30.1" /etc/kestrel/kestrel.conf
#         
#         set_key_value PrintMotd no /etc/ssh/sshd_config " "
#             Use a space as the separator
#

set_key_value() {
    local    key="${1}"
    local  value="${2}"
    local   file="${3}"
    
    local sep_re="${4:-=}"
    local    sep="${5:-${sep_re}}"
    local  space="${6:-\s*}"
    
    # If a whitespace is used as a separator, generalize its regular expression
    [[ "${sep_re}" == " " && "${sep}" == " " ]] && sep_re="\s"
    
    if [ ! -e ${file} ] || ! grep -qE "^${space}${key}${space}${sep_re}" ${file}
    then
        echo "${key}${sep}${value}" >> ${file}
    else
        sed -ri "/^(${space})${key}${sep}.*$/s||\1${key}${sep}${value}|" ${file}
    fi
}

