#!/bin/bash


# create_evaluation_script
# 
#     Creates a sed script for replacing the variables found on templates with
#     their values.

create_evaluation_script() {
    # Apply variable sustitution rules when a non escaped "$" character is found
    evaluation_script='/(^|[^\\])\$/{'
    
        # Create a sustitution rule for each variable
        for var in $(variable_list); do
            re='s#\$\{?'"${var}"'\}?#'"${!var}"'#g;'
            evaluation_script="${evaluation_script}${re}"
        done
    
    export evaluation_script="${evaluation_script}"'};s/\\\$/\$/g'
}


# find_templates <subdir> [<find options>]
# 
#     Returns a list of templates found on <subdir>.
# 
#     Notes:
#       - Any template can be replaced by the user including a template with the 
#         same name on /etc/kestrel/ directory.
#       - Labels allow to have multiple templates/scripts for a single file.
#       - When a template is replaced, only the replaced file's flags will be
#     
#     Each line contains the following data:
#         </path/to/the/template> <template_name> <flags> <label>
#     
#     Example:
#         /home/jonan/test/usr/image/etc/ssh(mode=0400)/kestrel image/etc/ssh(mode=0400)/kestrel
#     

find_templates() {
    local  subdir=$1
    shift
    
    local file
    local label
    local path
    local flags_re
    local find_re
    
    exec 3>&2-
    exec 2>/dev/null
    
    # Absolute path to KESTREL_SHARE and to KESTREL_ETC
    local share_dir
    local   etc_dir
    
    [ -d "${KESTREL_ETC}" ] &&
      etc_dir=$( cd   ${KESTREL_ETC}/${subdir}; pwd)
    share_dir=$( cd ${KESTREL_SHARE}/${subdir}; pwd)
    
    # Obtain only the path ignoring the flags (contained between parenthesis)
    #local path_re="(([^\/]*\/)*[^\(\/]+)"
    local path_re="(([^\(]+))"
    # Obtain: 1.- the string with the parenthesis
    #         2.- the string between the parenthesis (the flags)
    #         3.- the string between "" (the label)
    local flags_re="(\(([^\"]*(\"[^\"]*\")?.*)\))?"
    
    # List scripts on ${share_dir} and on ${etc_dir}
    ( 
      cd ${share_dir} &&
      find . -type f $@
      
      [ -n "${etc_dir}" ] &&
      cd ${etc_dir} &&
      find . -type f $@
      
    ) | \
    
    # - Delete the starting "./". 
    # - Output the filename without any flag.
    # - Output the label. A script only gets overriden by one on ${etc_dir} if
    #   the the script has the same filename and the same label.
    sed -r 's#^\./'"${path_re}${flags_re}"'$#\1 \5#' | \
    
    # sort them and remove duplicates
    sort | uniq | \
    
    while read file label; do
        
        [ -n "${label}" ] &&
        flags_re="([^\"]*${label}[^\"]*)" ||
        flags_re="\(([^\"]*)\)?"
        
        find_re="^\(${etc_dir}\|${share_dir}\)/+${file}${flags_re}$"
        
        find ${etc_dir:+${etc_dir}/} ${share_dir}/ \
             -regex "${find_re}" -type f -print -quit
        
    done | \
    
    sed -r "s#^(${share_dir}|${etc_dir})/${path_re}${flags_re}"'$#\0 \2 \5 \6#'
    
    exec 2>&-
    exec 2>&3-
}


# run_template <template_path> <template> <flags> <label> 
#                <os_dir> <flags2> <args>+
# 
#     Template information (obtained from a "find_templates" call)
#
#       <template_path>   = Path to the template/script
#       <template>        = Name of the template/script
#       <flags>           = Flags
#       <label>           = Label
#     
#     Context parameters
#       
#       <os_dir>          = "" or an image directory.
#       <flags2>          = Additional flags. Useful for overriding the default 
#                           flags.
#       <args>            = @("install" | "uninstall" | "enable" | "disable") +
#                           more_options*
#

run_template() {
    local   path=$1
    local   file=$(evaluate_template <<<$2)
    local  flags=$3
    local  label=$4
    local os_dir=${5%/}
    local flags2=$6
    
    shift 6
    
    local action=$1
    local   args=$@
    
    # default values
    local chroot
    local run
    local user
    local group
    local mode
    local link
    local label
    
    local flag
    local dest_file
    local dest_stat
    local FILE
    
    local IFS="\,"
    
    # Check flags
    for flag in ${flags} ${flags2}; do
        
        case "${flag}" in
            
            # chroot mode or nochroot mode (by default)
            chroot)
                chroot="yes"
                ;;
            nochroot)
                unset chroot
                ;;
            
            #  edit mode or template mode (by default)
            edit|run)
                run="${flag}"
                ;;
            template)
                unset run
                ;;
            
            # OS flags
            os=*-*)
                [ "${flag#os=}"   == "${OS_DISTRIBUTION}-${OS_CODENAME}" ] ||
                [ "${flag#os=}"   == "${OS_DISTRIBUTION}-${OS_RELEASE}"  ] ||
                return 0
                ;;
            os=*)
                [ "${flag#os=}"   == "${OS_DISTRIBUTION}" ] ||
                return 0
                ;;
            arch=*)
                [ "${flag#arch=}" == "${OS_ARCHITECTURE}" ] ||
                return 0
                ;;
            
            # Mode flags
            user=*)
                user=${flag#user=}
                ;;
            group=*)
                group=${flag#group=}
                ;;
            mode=*)
                mode=${flag#mode=}
                ;;            
            link=*)
                link=${flag#link=}
                ;;
            
            # Check a variable flag
            \$[a-zA-Z\-\_]*$|\$\{[a-zA-Z\-\_]*\})
                if [[ "${flag}" =~ ^\$\{?([^}]*)\}?$ ]] &&
                   [[ "${!BASH_REMATCH[1]}" != "yes" ]]; then
                    restore_file
                    return 0
                fi
                ;;
            
            # Label
            \"*\")
                label=${flag}
                ;;
            
            sh|python)
                ;;
            
            ?*)
                echo "unsupported flag: \"${flag}\" on dir: \"${dir}\""
                ;;
        esac
    done
    
    export file action user group mode link
    
    if [ -n "${run}" ]; then
        
        echo "script: ${path}"
        echo "tofile: ${file}"
        [ -n "${label}" ] && echo "label:  ${label}"
        [ -n "${user}"  ] && echo "user:   ${user}"
        [ -n "${group}" ] && echo "group:  ${group}"
        [ -n "${mode}"  ] && echo "mode:   ${mode}"
        [ -n "${link}"  ] && echo "link:   ${link}"
        
        local tofile=${file}
        
        # Ensure an editted file exits or create a backup
        [[ "${run}" == "edit" ]] &&
            if [ -f "${os_dir}/${file}" ]; then     
                test_backup
                
            else
                mkdir -p "${os_dir}/${file%/*}"
                touch -d "@0" "${os_dir}/${file}"
            fi
        
        # Under a chroot?
        if [[ ! -n "${chroot}" ]]; then
            
            FILE="${os_dir}/${file}"
            
            . "${path}" ${args}
            
        else
            export FILE=${file}
            
            # Copy the basic chroot kestrel-lib
            cat < ${KESTREL_SHARE}/kestrel-chroot-lib > ${os_dir}/tmp/hook
            
            # Copy the script to the chroot
            cat < ${path} >> ${os_dir}/tmp/hook
            chmod 755 ${os_dir}/tmp/hook
            
            # Avoid any locale setting
            export LANG=C
            echo chroot ${os_dir} /tmp/hook ${args}
            
            rm /tmp/hook
        fi
        
        [[ "${run}" == "edit" ]] &&
            perms_and_backup
        
    else
        echo "template: ${path}"
        echo "tofile:   ${file}"
        [ -n "${user}"  ] && echo "user:     ${user}"
        [ -n "${group}" ] && echo "group:    ${group}"
        [ -n "${mode}"  ] && echo "mode:     ${mode}"
        [ -n "${link}"  ] && echo "link:     ${link}"
        
        template_file "${path}" "${file}"
        
        [ "${file%/*}" == "/etc/init.d" ] && install_service
    fi
}

# install_service
# 
#     Create the links of init scripts

install_service() {
    
    [ -n "chroot" ] && chroot="chroot ${os_image}"
    
    if [[ ! "${args}" == @(install|enable) ]]; then
        
        ${chroot} update-rc.d -f ${file} remove

    else
        # Remove the init script links
        ${chroot} update-rc.d -f ${file} remove >/dev/null
        
        local start
        local  stop
        
        start=$(sed -rn 's/\s*#\s*Run-Level-Start:\s*([0-9]+)$/\1/p' ${path})
         stop=$(sed -rn 's/\s*#\s*Run-Level-Stop:\s*([0-9]+)$/\1/p'  ${path})
        
        [ -z "${start}" ] && start=20
        [ -z "${stop}"  ] &&  stop=20
        
        # Add the start and stop links
        ${chroot} update-rc.d ${file} start ${start} .
        ${chroot} update-rc.d ${file} stop  ${stop} .
    fi
}


# search_backup_files
# 
#     Searches a backup file

search_backup_file() {
    local file=${file:-$1}
    local result
    
    #   ${file}  =~ [optional/path/]filename[.version]
    if [[ "${file}" =~ ^${backup_re}$ ]]; then
         dirname=${BASH_REMATCH[1]}
         version=${BASH_REMATCH[3]%\:actual}
         version=${version:-\:last}
        filename=${BASH_REMATCH[2]%${version}}
    else
        die "Invalid filename: \"${file}\""
    fi
    
    # Look for the file
    if [[ ! -e "${os_dir}/${KESTREL_BACKUP_DIR}/${file}" ]]; then
        # Escape the dots for using it as a the regular expression
        local file_re="${dirname}${filename}${version}"
              file_re="${file_re//./\\.}"
        [[ "${version}" =~ ^${version_link_re}$ ]] &&
        result=$( find "${os_dir}/${KESTREL_BACKUP_DIR%/}/"  -type l \
                       -iregex "^.*/${file_re}$" -print -quit ) ||
        result=$( find "${os_dir}/${KESTREL_BACKUP_DIR%/}/"  \
                       -iregex "^.*/${file_re}$" -print -quit )
    else
        result="${os_dir}/${KESTREL_BACKUP_DIR%/}/${file}"
    fi
    
    if [ -z "${result}" ]; then
        die "File not found: \"${file}\""
    
    elif [ -L "${result}" ]; then
        version=$(readlink -n "${result%/*}/${filename}${version}")
        file="${result#${os_dir}/${KESTREL_BACKUP_DIR%/}/}"
        result="${file%/*}/${version}"
    
    else
        result="${result#${os_dir}/${KESTREL_BACKUP_DIR%/}/}"
    fi
    
    [[ "${result}" =~ ^${backup_re}$ ]]
     dirname=${BASH_REMATCH[1]}
     version=${BASH_REMATCH[3]}
    filename=${BASH_REMATCH[2]%${version}}
}


# list_backup_versions <os_dir> file[.(version|last|actual)]
# 
#     

list_backup_versions() {
    local os_dir="${1}"
    local   file="${2}"
    local dirname
    local version
    local filename
    
    search_backup_file "${file}"
    
    ( cd "${os_dir}/${KESTREL_BACKUP_DIR}/${dirname}"
      
      # List backup files which match the regular expression
      find . -regextype posix-egrep \
             \( -type l -iregex ".*/${filename}${version_link_re}$" \) \
             -o         -iregex ".*/${filename}${version_back_re}$" |
      
      # Remove "./". Add a new entry ".actual" for each ".last" entry
      sed -r 's#.*'"${version_re}"'$#\1#; s#last#last\nactual#' )
}


# list_original_files <os_dir>
# 
#     

list_original_files() {
    local os_dir="${1}"
    
    ( cd "${os_dir}/${KESTREL_BACKUP_DIR}/";
    
      # List backup files which match the regular expression
      find . -type l -regextype posix-egrep -iregex "${backup_link_re}$" | 
      
      # Remove "./". Show only last files
      sed -rn 's#\.\/##; s#^(.*)\:orig$#\1#p' ) | sort
}


# list_backup_files <os_dir> [file[:(version|last|actual)]]
# 
#     

list_backup_files() {
    local os_dir="${1}"
    local   file="${2}"
    local dirname
    local version
    local filename
    
    if [ -n "${file}" ]; then
        search_backup_file "${file}"
        
        ( cd "${os_dir}/${KESTREL_BACKUP_DIR}/"

          filename="${dirname}${filename}"

          find . -regextype posix-egrep \
             \( -type l -iregex ".*/${filename}${version_link_re}$" \) \
             -o         -iregex ".*/${filename}${version_back_re}$" |
          
          # Remove "./". Add a new entry ":actual" for each ":last" entry
          sed -r 's#\.\/##; s#^((.*)\:last)$#\1\n\2:actual#' )
     
     else
        ( cd "${os_dir}/${KESTREL_BACKUP_DIR}/";
        
          # List backup files which match the regular expression
          find . -regextype posix-egrep \
             \( -type l -iregex "${backup_link_re}$" \) \
             -o         -iregex "${backup_back_re}$" | 
          
          # Remove "./". Add a new entry ".actual" for each ".last" entry
          sed -r 's#\.\/##; s#^((.*)\:last)$#\1\n\2:actual#' )
     fi | sort
}
