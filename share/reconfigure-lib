#!/bin/bash


# create_evaluation_script
# 
#     Creates a sed script for replacing the variables found on templates with
#     their values.

create_evaluation_script() {
    # Apply variable sustitution rules when a non escaped "$" character is found
    local script='/(^|[^\\])\$/{'
    
    # Create a sustitution rule for each variable
    for var in $(variable_list); do
        re='s#\$\{?'"${var}"'\}?#'"${!var}"'#g;'
        script="${script}${re}"
    done
    
    [ -n "${image_name}" ] && 
        script="${script}"'s#\$\{?'"${image_name}"'\}?#'"${!image_name}"'#g;'
    
    [ -n "${image_dir}" ] && 
        script="${script}s"'#\$\{?'"${image_dir}"'\}?#'"${!image_name}"'#g;'
    
    export evaluation_script="${script}"'};/\\\$(\w|\{)/s/\\\$/$/g'
}


# find_templates <subdir> [<find options>]
# 
#     Returns a list of templates found on <subdir>.
# 
#     Notes:
#       - Any template can be replaced by the user including a template with the 
#         same name on /etc/kestrel/ directory.
#       - Labels allow to have multiple templates/scripts for a single file.
#       - When a template is replaced, only the replaced file's flags will be
#     
#     Each line contains the following data:
#         </path/to/the/template> <template_name> <flags> <label>
#     
#     Example:
#         /home/jonan/test/usr/image/etc/ssh(mode=0400)/kestrel image/etc/ssh(mode=0400)/kestrel
#     

find_templates() {
    local  subdir=$1
    shift
    
    local file
    local label
    local path
    local flags_re
    local find_re
    
    exec 3>&2-
    exec 2>/dev/null
    
    # Absolute path to KESTREL_SHARE and to KESTREL_ETC
    local share_dir
    local   etc_dir
    
    [ -d "${KESTREL_ETC}" ] &&
      etc_dir=$( cd   ${KESTREL_ETC}/${subdir}; pwd)
    share_dir=$( cd ${KESTREL_SHARE}/${subdir}; pwd)
    
    # Obtain only the path ignoring the flags (contained between parenthesis)
    #local path_re="(([^\/]*\/)*[^\(\/]+)"
    local path_re="(([^\(]+))"
    # Obtain: 1.- the string with the parenthesis
    #         2.- the string between the parenthesis (the flags)
    #         3.- the string between "" (the label)
    local flags_re="(\(([^\"]*(\"[^\"]*\")?.*)\))?"
    
    # List scripts on ${share_dir} and on ${etc_dir}
    ( 
      cd ${share_dir} &&
      find . -type f $@
      
      [ -n "${etc_dir}" ] &&
      cd ${etc_dir} &&
      find . -type f $@
      
    ) | \
    
    # - Delete the starting "./". 
    # - Output the filename without any flag.
    # - Output the label. A script only gets overriden by one on ${etc_dir} if
    #   the the script has the same filename and the same label.
    sed -r 's#^\./'"${path_re}${flags_re}"'$#\1 \5#' | \
    
    # sort them and remove duplicates
    sort | uniq | \
    
    while read file label; do
        
        [ -n "${label}" ] &&
        flags_re="([^\"]*${label}[^\"]*)" ||
        flags_re="\(([^\"]*)\)?"
        
        find_re="^\(${etc_dir}\|${share_dir}\)/+${file}${flags_re}$"
        
        find ${etc_dir:+${etc_dir}/} ${share_dir}/ \
             -regex "${find_re}" -type f -print -quit
        
    done | \
    
    sed -r "s#^(${share_dir}|${etc_dir})/${path_re}${flags_re}"'$#\0 \2 \5 \6#'
    
    exec 2>&-
    exec 2>&3-
}


# check_flags
# 
#     
check_flags() {
    local flag
    
    for flag in ${flags} ${flags2}; do
        
        case "${flag}" in
            
            # chroot mode or nochroot mode (by default)
            chroot)
                chroot="yes"
                ;;
            nochroot)
                unset chroot
                ;;
            
            #  edit mode or template mode (by default)
            edit|run|package)
                run="${flag}"
                ;;
            template)
                unset run
                ;;
            
            # OS flags
            os=*-*)
                [ "${flag#os=}"   == "${OS_DISTRIBUTION}-${OS_CODENAME}" ] ||
                [ "${flag#os=}"   == "${OS_DISTRIBUTION}-${OS_RELEASE}"  ] ||
                return 0
                ;;
            os=*)
                [ "${flag#os=}"   == "${OS_DISTRIBUTION}" ] ||
                return 0
                ;;
            arch=*)
                [ "${flag#arch=}" == "${OS_ARCHITECTURE}" ] ||
                return 0
                ;;
            
            # Mode flags
            user=*)
                user=${flag#user=}
                ;;
            group=*)
                group=${flag#group=}
                ;;
            mode=*)
                mode=${flag#mode=}
                ;;            
            link=*)
                link=${flag#link=}
                ;;
            
            # Check a variable flag
            \$[a-zA-Z\-\_]*$|\$\{[a-zA-Z\-\_]*\})
                if [[ "${flag}" =~ ^\$\{?([^}]*)\}?$ ]] &&
                   [[ "${!BASH_REMATCH[1]}" != "yes" ]]; then
                    
                    # Only restore if we are really running the template
                    [ -n "${action}" ] && restore_file
                    return 0
                fi
                ;;
            
            # Label
            \"*\")
                label=${flag}
                
                # Check if the label is disabled
                variable=${label}_disabled
                [ "${!variable}" == "true" ] && return 0
                
                variable=${label}_${image_name}_disabled
                [ "${!variable}" == "true" ] && return 0
                ;;
            
            sh|python)
                ;;
            
            ?*)
                echo "unsupported flag: \"${flag}\" on dir: \"${dir}\""
                ;;
        esac
    done
}


# run_template <template_path> <template> <flags> <label> 
#                <os_dir> <flags2> <args>+
# 
#     Template information (obtained from a "find_templates" call)
#
#       <template_path>   = Path to the template/script
#       <template>        = Name of the template/script
#       <flags>           = Flags
#       <label>           = Label
#     
#     Context parameters
#       
#       <os_dir>          = "" or an image directory.
#       <flags2>          = Additional flags. Useful for overriding the default 
#                           flags.
#       <args>            = @("install" | "uninstall" | "enable" | "disable") +
#                           more_options*
#

run_template() {
    local   path=$1
    local   file=$(evaluate_template <<<$2)
    local  flags=$3
    local  label=$4
    local os_dir=${5%/}
    local flags2=$6
    
    shift 6
    
    local action=$1
    local   args=$@
    
    # default values
    local chroot
    local run
    local user
    local group
    local mode
    local link
    local label
    
    local dest_file
    local dest_stat
    local FILE
    
    local IFS="\,"
    
    check_flags
    
    export file action user group mode link
    
    if [ -n "${run}" ]; then
        
        if [[ "${args}" == @(install|enable) ]]; then
            
            echo "script: ${path}"
            echo "tofile: ${file}"
            [ -n "${label}" ] && echo "label:  ${label}"
            [ -n "${user}"  ] && echo "user:   ${user}"
            [ -n "${group}" ] && echo "group:  ${group}"
            [ -n "${mode}"  ] && echo "mode:   ${mode}"
            [ -n "${link}"  ] && echo "link:   ${link}"
            echo
            
            local tofile=${file}
            
            # If a file is being edited, first create a backup or create the file
            [[ "${run}" == "edit" ]] &&
                if [ -f "${os_dir}/${file}" ]; then     
                    test_backup
                    
                else
                    mkdir -p "${os_dir}/${file%/*}"
                    touch -d "@0" "${os_dir}/${file}"
                fi
            
            # Run the package script
            if [[ "${run}" == "package" ]]; then
                local packages=$(. ${path} )
                
                echo -e "install:${packages}\n" \
                    >> ${os_dir}/${KESTREL_LOG_DIR}/apt-history
                
                echo -e "install:${packages}\n" \
                    >> ${os_dir}/${KESTREL_LOG_DIR}/apt-output
                
                export LANG=C
                export DEBIAN_FRONTEND=noninteractive
                export DEBIAN_PRIORITY=critical
                export DEBCONF_NONINTERACTIVE_SEEN=true
                
                chroot ${os_dir} apt-get -q -y --force-yes install ${packages} \
                    >> ${os_dir}/${KESTREL_LOG_DIR}/apt-output
            
            # Run the edit or run script under a chroot
            elif [[ ! -n "${chroot}" ]]; then
                
                FILE="${os_dir}/${file}"
                
                . "${path}" ${args}
                
            # Run the edit or run script
            else
                export FILE=${file}
                
                # Copy the basic chroot kestrel-lib
                cat < ${KESTREL_SHARE}/kestrel-chroot-lib > ${os_dir}/tmp/hook
                
                # Copy the script to the chroot
                cat < ${path} >> ${os_dir}/tmp/hook
                chmod 755 ${os_dir}/tmp/hook
                
                # Avoid any locale setting
                export LANG=C
                chroot ${os_dir} /tmp/hook ${args}
                
                rm /tmp/hook
            fi
            
            [[ "${run}" == "edit" ]] &&
                perms_and_backup
            
        else
            echo "file: ${file}"
            echo
            
            if [[ "${run}" == "edit" ]]; then
                restore_file
            
            # Run the package script
            elif [[ "${run}" == "package" && -z "${os_dir}" ]]; then
                local packages=$(. ${path} )
                
                echo -e "remove:${packages}\n" \
                    >> ${os_dir}/${KESTREL_LOG_DIR}/apt-history
                
                echo -e "remove:${packages}\n" \
                    >> ${os_dir}/${KESTREL_LOG_DIR}/apt-output
                
                export LANG=C
                export DEBIAN_FRONTEND=noninteractive
                chroot ${os_dir} apt-get -qq -y remove ${packages} \
                    >> ${os_dir}/${KESTREL_LOG_DIR}/apt-output
            fi
        fi
        
    else
        
        if [[ ! "${args}" == @(install|enable) ]]; then
            restore_file
        else
            echo "template: ${path}"
            echo "tofile:   ${file}"
            [ -n "${user}"  ] && 
                echo "user:     ${user}"  ||  user=$(stat -c %u "${path}")
            [ -n "${group}" ] && 
                echo "group:    ${group}" || group=$(stat -c %g "${path}")
            [ -n "${mode}"  ] && 
                echo "mode:     ${mode}"  ||  mode=$(stat -c %a "${path}")
            [ -n "${link}"  ] && echo "link:     ${link}"
            echo
            
            template_file "${path}" "${file}"
        fi
        
        [ "${file%/*}" == "/etc/init.d" ] && install_service
    fi
}

# install_service
# 
#     Create the links of init scripts

install_service() {
    
    [ -n "chroot" ] && chroot="chroot ${os_image}"
    
    if [[ ! "${args}" == @(install|enable) ]]; then
        
        ${chroot} update-rc.d -f ${file} remove
        
    else
        # Remove the init script links
        ${chroot} update-rc.d -f ${file} remove >/dev/null
        
        local start
        local  stop
        
        start=$(sed -rn 's/\s*#\s*Run-Level-Start:\s*([0-9]+)$/\1/p' ${path})
         stop=$(sed -rn 's/\s*#\s*Run-Level-Stop:\s*([0-9]+)$/\1/p'  ${path})
        
        [ -z "${start}" ] && start=20
        [ -z "${stop}"  ] &&  stop=20
        
        # Add the start and stop links
        ${chroot} update-rc.d ${file} start ${start} .
        ${chroot} update-rc.d ${file} stop  ${stop} .
    fi
}


# search_backup_files
# 
#     Searches a backup file

search_backup_file() {
    local file=${file:-$1}
    local result
    
    #   ${file}  =~ [optional/path/]filename[.version]
    if [[ "${file}" =~ ^${backup_re}$ ]]; then
         dirname=${BASH_REMATCH[1]}
         version=${BASH_REMATCH[3]%\:actual}
         version=${version:-\:last}
        filename=${BASH_REMATCH[2]%${version}}
    else
        die "Invalid filename: \"${file}\""
    fi
    
    # Look for the file
    if [[ ! -e "${os_dir}/${KESTREL_BACKUP_DIR}/${file}" ]]; then
        # Escape the dots for using it as a the regular expression
        local file_re="${dirname}${filename}${version}"
              file_re="${file_re//./\\.}"
        if [[ "${version}" =~ ^${version_link_re}$ ]]; then
            result=$( find "${os_dir}/${KESTREL_BACKUP_DIR%/}/"  -type l \
                           -iregex "^.*/${file_re}$" -print -quit )
        else
            result=$( find "${os_dir}/${KESTREL_BACKUP_DIR%/}/"  \
                           -iregex "^.*/${file_re}$" -print -quit )
        fi
    else
        result="${os_dir}/${KESTREL_BACKUP_DIR%/}/${file}"
    fi
    
    if [ -z "${result}" ]; then
        die "File not found: \"${file}\""
    
    elif [ -L "${result}" ]; then
        version=$(readlink -n "${result%/*}/${filename}${version}")
        file="${result#${os_dir}/${KESTREL_BACKUP_DIR%/}/}"
        result="${file%/*}/${version}"
    
    else
        result="${result#${os_dir}/${KESTREL_BACKUP_DIR%/}/}"
    fi
    
    [[ "${result}" =~ ^${backup_re}$ ]]
     dirname=${BASH_REMATCH[1]}
     version=${BASH_REMATCH[3]}
    filename=${BASH_REMATCH[2]%${version}}
}


# list_backup_versions <os_dir> file[.(version|last|actual)]
# 
#     List the versions of a saved file

list_backup_versions() {
    local os_dir="${1}"
    local   file="${2}"
    local dirname
    local version
    local filename
    
    search_backup_file "${file}"
    
    ( cd "${os_dir}/${KESTREL_BACKUP_DIR}/${dirname}"
      
      # List backup files which match the regular expression
      find . -regextype posix-egrep \
             \( -type l -iregex ".*/${filename}${version_link_re}$" \) \
             -o         -iregex ".*/${filename}${version_back_re}$" |
      
      # Remove "./". Add a new entry ".actual" for each ".last" entry
      sed -r 's#.*'"${version_re}"'$#\1#; s#last#last\nactual#' )
}


# list_original_files <os_dir>
# 
#     List the saved original files

list_original_files() {
    local os_dir="${1}"
    
    ( cd "${os_dir}/${KESTREL_BACKUP_DIR}/";
    
      # List backup files which match the regular expression
      find . -type l -regextype posix-egrep -iregex "${backup_link_re}$" | 
      
      # Remove "./". Show only last files
      sed -rn 's#\.\/##; s#^(.*)\:orig$#\1#p' ) | sort
}


# list_backup_files <os_dir> [file]
# 
#     List all the versions of all the saved files or list all the versions of
#     a saved file.

list_backup_files() {
    local os_dir="${1}"
    local   file="${2}"
    local dirname
    local version
    local filename
    
    if [ -n "${file}" ]; then
        search_backup_file "${file}"
        
        ( cd "${os_dir}/${KESTREL_BACKUP_DIR}/"

          filename="${dirname}${filename}"

          find . -regextype posix-egrep \
             \( -type l -iregex ".*/${filename}${version_link_re}$" \) \
             -o         -iregex ".*/${filename}${version_back_re}$" |
          
          # Remove "./". Add a new entry ":actual" for each ":last" entry
          sed -r 's#\.\/##; s#^((.*)\:last)$#\1\n\2:actual#' )
     
     else
        ( cd "${os_dir}/${KESTREL_BACKUP_DIR}/";
        
          # List backup files which match the regular expression
          find . -regextype posix-egrep \
             \( -type l -iregex "${backup_link_re}$" \) \
             -o         -iregex "${backup_back_re}$" | 
          
          # Remove "./". Add a new entry ".actual" for each ".last" entry
          sed -r 's#\.\/##; s#^((.*)\:last)$#\1\n\2:actual#' )
     fi | sort
}


# diff_files <file1> <file2>
# 
#     Compare files file1 and file2

diff_files() {
    local os_dir="${1}"
    local  file1="${2}"
    local  file1="${3}"
    local dirname
    local version
    local filename
    
    if [ ! -e "${file1}" ]; then
        search_backup_file "${file1}"
        file1="${dirname}/${filename}/${version}"
    fi
    
    if [ ! -e "${file2}" ]; then
        search_backup_file "${file2}"
        file2="${dirname}/${filename}/${version}"
    fi
    
    diff -urN ${file1} ${file2}
}


# log functions
################

list_log_times() {
    local stage="${1}"
    local   log="${image_dir}/${KESTREL_LOG_DIR}/${stage}"
    
    [ -e "${log}" ] && grep -E "${log_time_re}" "${log}"
}


show_log_file() {
    local stage="${1}"
    local  time="${2}"
    local   log="${image_dir}/${KESTREL_LOG_DIR}/${stage}"
    
    if [ -z "${time}" ]; then
        time=$(list_log_times ${1} | tail -n1)
    elif ! [[ ${time} =~ ${log_time_re} ]]; then
        die "Invalid time: ${time}"
    fi
    
    [ -e "${log}" ] && sed -rn "/^${time}$/,/^${log_time_re}$/ {
        /^${log_time_re}$/!p; /^${time}$/p; }" "${log}"
}


list_log_files() {
    ls -1 ${image_dir}/${KESTREL_LOG_DIR}
}


# stage configuration functions
################################

# run_configuration_stage <stage> [<optional flags>]
# 
#     Runs the configuration stage
#     
#     Note: Requires $image_dir and $image_name to be already set

run_configuration_stage() {
    local stage="${1}"
    local oflag="${2}"
    local   log="${image_dir}/${KESTREL_LOG_DIR}/${stage}"
    local   dir
    
    if [ -z "${image_dir}" ]; then
        dir="system/${stage}.d"
    else
        dir="node/${stage}.d"
    fi
    
    mkdir -p "${log%/*}"
    
    {
        echo ${config_date:-$(date "+%F %T")}
        echo "===================" 
    } >> "${log}" 2>&1
    
    find_templates "${dir}" -iregex '.*/check\..*' |
    while read path FILE flags label; do
        echo "${FILE}"
        run_template "${path}" "${FILE}" "${flags}" "${label}" \
                     "${image_dir}" "run,${oflag}" "${event}"  \
                     >> "${log}" 2>&1
        
    done
    
    find_templates "${dir}" ! -iregex '.*/\(check\|run\|restart\)\..*' |
    while read path FILE flags label; do
        echo "${FILE}"
        run_template "${path}" "${FILE}" "${flags}" "${label}" \
                     "${image_dir}" "${oflag}"     "${event}"  \
                     >> "${log}" 2>&1
        
    done
    
    find_templates "${dir}" -iregex '.*/\(run\|restart\)\..*' |
    while read path FILE flags label; do
        echo "${FILE}"
        run_template "${path}" "${FILE}" "${flags}" "${label}" \
                     "${image_dir}" "run,${oflag}" "${event}"  \
                     >> "${log}" 2>&1
        
    done
}


# applicable_templates <stage>
# 
#     List applicable templates
#     
#     Note: Requires $image_dir and $image_name to be already set

applicable_templates() {
    local stage="${1}"
    local dir
    
    if [ -z "${image_dir}" ]; then
        dir="system/${stage}.d"
    else
        dir="node/${stage}.d"
    fi
    
    find_templates "${dir}" |
    while read path FILE flags label; do
        check_flags
        echo "${FILE}"
    done
}
