#!/bin/bash

# kestrel-daemon
#
# Run register scripts when a new event occurs.
# Those event are notified to the daemon througth the rpc/fifo
#

[ -z   "$KESTREL_SHARE" ] && KESTREL_SHARE=/usr/share/kestrel
[ ! -d "$KESTREL_SHARE" ] && KESTREL_SHARE="${0%/*}/share"

# Load kestrel_lib
. "$KESTREL_SHARE"/kestrel-lib
. "$KESTREL_SHARE"/node-status-lib

# Export loaded configuration
export_config

# Local variables
NAME=${0##*/}
LOGFILE=/var/log/${NAME}.log
PIDFILE=/var/run/${NAME}.pid
LOCKFILE=/var/lock/${NAME}.lock

# Set verbose flag
VERBOSE=yes


# Check parameters
case $1 in
    --version|-v)
        kestrel_version
        exit 0
        ;;
    --help)
        echo "KestrelHPC daemon"
        exit 0
        ;;
esac


# Check if the daemon is already running
if [[ -e "${PIDFILE}" &&
      -e "/proc/$(cat ${PIDFILE})" ]]; then
      
    echo "${NAME} already running"
    exit 1
    
fi

# Remove the PIDFILE and exit when the daemon receives a SIGTERM signal
close() {
   exec 200> ${LOCKFILE}
   flock -x 200
   rm -f ${PIDFILE}
   rm -f ${LOCKFILE}
   exit 0 
}


# run_event_scripts <parameters>*

run_event_scripts() {

    msg ""                          \
        "======================"    \
        ""                          \
        $(date)                     \
        ""                          \
        " Event's parameters : "    \
        ""
    
    # Export the variables of the event. For security reasons we check if a
    # variable is trying to replace an existing variable. We only allow to
    # export non existant variables.
    for param in $@; do
         
         # Check if parameter is a key=value
         if [[ "${param}" =~ [0-9A-Za-z_]+=.+ ]]; then
             
             key=${param%%=*}
             value=${param#*=}
             
             # Only export the "key" variable if it is undefined.
             if [ -z "${!key}" ]; then
                 export ${key}=${value}
                 
                 # Debug :
                 echo "${key}=${!key}"
             fi
         fi
    done
    
    # Check we don't get an invalid event (an event with an empty action)
    [ -z "${action}" ] && { echo "Unexpected event."; return 0; }
    
    
    # Get the mac from the ip using the arp cache
    [ -z "${mac}" ] &&
    mac=$( arp -ni ${KESTREL_IFACE} | \
           awk "/^${ip//./\\.}[\s\t\ ]/ { print \$3 }" )
    
    # Get the hostname from the registered node file.
    [ -z "${hostname}" ] &&
    hostname=$( mac_2_hostname "${mac}" )
    
    # Get the group name from the hostname
    [ -z "${group}" ] && 
    [[ "${hostname}" =~ ^${KESTREL_HOSTNAME}-(${group_re})-${node_re}$ ]] &&
    group=${BASH_REMATCH[1]}
    
    
    case "${action}" in
        # When registering, asign a hostname for the node
        register)
            # Check if the node is not registered to the same group
            if ! registered_nodes "${group}" | grep -Eq "^${hostname}$"; then

                # Look for the last registered node number
                re="^${KESTREL_HOSTNAME}-${group_re}-(${node_re})$"
                
                last_node=$( registered_nodes ${group} | sed -rn "s/${re}/\1/p" |\
                             sort -n | tail -n1 )
                
                [ -z "${last_node}" ] && last_node=0
                
                hostname=${KESTREL_HOSTNAME}-${group}-$(( ${last_node} + 1 ))
                msg "Registering node \"${hostname}\""                  \
                    "\tmac : ${mac}"                                    \
                    "\tip  : ${ip}"                                     \
                    ""
            else
                msg "The node \"${hostname}\" was already registered"   \
                    "\tmac : ${mac}"                                    \
                    "\tip  : ${ip}"                                     \
                    ""
            fi >> ${KESTREL_DATA_DIR}/register_feedback
            ;;
            
        # Check if the node is registered
        connect)
            [ -z "$(mac_2_hostname ${mac})" ] && { 
                echo "This node is not a registered node."; return 0;
            }
            
            # Ignore re"connect" events if the node is connected.
            connected_nodes | grep -Eq "^${hostname}\$" && return 0
            ;;
    esac
    
    msg ""                          \
        "action   : ${action}"      \
        "mac      : ${mac}"         \
        "ip       : ${ip}"          \
        "hostname : ${hostname}"    \
        "group    : ${group}"       \
        ""                          \
        "----------------------"    \
        ""
    
    # Run event.d script.
    list_scripts "event.d" | \
    while read script; do
        echo ${script}
        . ${script}
    done

    msg ""                          \
        "======================"    \
        ""
}


# fork twice so the innermost subshell detaches from the current process
(   (
        # Delete the lock
        rm "${LOCKFILE}" &>/dev/null
        
        trap close SIGINT SIGTERM
        
        while :; do
            while read read_line; do
                ( 
                #    flock -s 200
                    
                    # Run the event scripts when we read a line
                    run_event_scripts ${read_line}
                    
                ) # 200> ${LOCKFILE} &
            done < ${KESTREL_RPC_FIFO}
        done >> ${LOGFILE} 2>&1
    
    ) >/dev/null </dev/null &

    # Write the pid of the innermost subshell to the PIDFILE
    echo $! > ${PIDFILE} 
)

exit 0
